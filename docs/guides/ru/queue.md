Очереди
=======

Очереди могут использоваться 
*   для интеграции с целью приема/передачи данных в другую систему,
*   для организации асинхронной обработки заданий в воркерах 
    (Event Loop), в том числе в режиме параллельной обработки.

Для работы с очередью в Iris CRM используется библиотека [Bernard](https://github.com/bernardphp/bernard).

Настройки
---------

Параметры очереди настраиваются в `settings.xml`:
```xml
   <QUEUE prefix="iris:"/>
```

*   `prefix` - это префикс названия очереди. Используется для совместного использования
сервера очередей различными системами.

По умолчанию задания обрабатыватся в синхронном режиме, используется
`Bernard\Queue\InMemoryQueue`. При необходимости вы можете выбрать
драйвер для вашего сервера очередей и настроить паралледбную обработку
заданий, для этого укажите соответсвующие классы в сервис провайдере.

*   `queue.factory` - фабрика, используемая для создания очереди. По умолчанию, 
в сервис провайдере зарегистрировано две фабрики: 
    *   `PersistentFactory` - создает очередь для реального сервера очередей.
        По умолчанию - для Redis на localhost. Если вы желаете работать с другим
        сервером очередей, измените описание сервиса `queue.driver` в сервис-провайдере.
        Также необходимо изменить описание сервиса `queue.producer`. По умолчанию
        используется `Iris\Queue\ConsumingProducer` для синхронного режима. 
        Замените этот класс на `Bernard\Producer`:
        ```php
        $this->container
            ->register('queue.factory', PersistentFactory::class)
            ->addArgument(new Reference('queue.driver'))
            ->addArgument(new Reference('queue.serializer'));
        $this->container
            ->register('queue.producer', Producer::class)
            ->addArgument(new Reference('queue.factory'))
            ->addArgument(new Reference('queue.event_dispatcher'));
        ```
    *   `InMemoryFactory` - используется для обработки без использования сервера очередей. 
        Как правило для выполнения заданий в синхронном режиме, когда задания обрабатываются
        сразу в момент отправки их в очередь. Такой вариант удобен для использования
        на стенде разработки, при выполнении автоматических тестов 
        и для маленьких проектов.

Отправка сообщений в очередь
----------------------------

Для отправки сообщения в очередь подключите к вашему классу трейт `DispatchesJobs`:
```php
use DispatchesJobs;
```
И вызовите метод `dispatch(string $queueName, array $message)`:
```php
$this->dispatch('my-queue-name', [
    'parameter1' => 'value1',
    'parameter2' => 'value2',
]);
```

Обработка заданий из очереди
----------------------------

Для обработки задания из очереди в асинхронном режиме создайте класс 
в вашей конфигурации в каталоге _Job_. Название класса должно совпадать 
с названием очереди, в котором удалены знаки "-" и первые символы после тире 
заменены на зклавные. В названии класса должен быть постфикс _Job_.

Пример обработчика:

```php
<?php

namespace MyConfig\Job;

use Bernard\Message\AbstractMessage;
use Iris\Job\AbstractJob;

class MyQueueNameJob extends AbstractJob
{

    /**
     * @inheritdoc
     */
    public function handle(AbstractMessage $message)
    {
        echo var_dump($message);
    }
}
```

Запуск воркера
--------------

Для запуска воркера используйте консольную команду

```bash
./iris iris:worker my-queue-name
```

Для параллельной обработки запустите несколько таких процессов.
Для автоматического перезапуска воркеров при сбоях и для управления 
количеством запущенных воркеров используйте [Supervisor](http://supervisord.org/) 
или другой привычный вам инструмент.